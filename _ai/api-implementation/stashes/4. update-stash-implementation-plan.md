# API Endpoint Implementation Plan: Update Stash Name

## 1. Endpoint Overview
This document outlines the implementation plan for the `PATCH /api/stashes/{stashId}` endpoint. This endpoint allows an authenticated user to rename one of their existing, active stashes. The update is conditional on the stash not being soft-deleted and the new name not conflicting with another active stash owned by the same user.

## 2. Request Details
- **HTTP Method:** `PATCH`
- **URL Structure:** `/api/stashes/{stashId}`
- **Parameters:**
  - **Path (Required):** `stashId` (UUID) - The unique identifier of the stash to be updated.
  - **Body (Required):** A JSON object containing the new name for the stash.
- **Request Body Example:**
  ```json
  {
    "name": "New Stash Name"
  }
  ```

## 3. Used Types
- **`UpdateStashNameDto` (New):** A Zod schema for validating the request body.
  ```typescript
  import { z } from 'zod';

  export const UpdateStashNameDto = z.object({
    name: z.string().min(1, 'Name cannot be empty.').max(100, 'Name cannot exceed 100 characters.'),
  });
  ```
- **`Stash` (Existing):** The entity type defined in `src/types.ts` will be used for the response payload.

## 4. Response Details
- **Success (200 OK):** On a successful update, the server will respond with the complete, updated stash object.
  ```json
  {
    "id": "...",
    "user_id": "...",
    "name": "New Stash Name",
    "current_balance": 1500.75,
    "created_at": "...",
    "updated_at": "...",
    "deleted_at": null
  }
  ```
- **Error:** See the Error Handling section for details on error responses.

## 5. Data Flow
1. The client sends a `PATCH` request to `/api/stashes/{stashId}` with the new name in the request body.
2. The Astro endpoint receives the request and extracts the `stashId` and the request body.
3. The endpoint validates the `stashId` format (must be a UUID) and uses the `UpdateStashNameDto` Zod schema to validate the request body.
4. The endpoint authenticates the user using `context.locals.supabase` and retrieves the session.
5. The core logic is delegated to a new service function, `updateStashName`, located in `src/lib/services/stash.service.ts`.
6. The `updateStashName` service function performs the following actions within a single database transaction:
   a. Verifies that an active stash (`deleted_at IS NULL`) exists with the given `stashId` and belongs to the authenticated `user_id`.
   b. Checks if the user already has another active stash with the new `name` to prevent duplicates.
   c. If all checks pass, it updates the `name` and `updated_at` fields of the specified stash record.
7. The service function returns the updated stash data.
8. The API endpoint formats the successful response with a `200 OK` status and the updated stash object or returns an appropriate error response.

## 6. Security Considerations
- **Authentication:** The endpoint must be protected, accessible only to authenticated users. This will be handled by Astro middleware which verifies the Supabase session from cookies.
- **Authorization:** The service logic must ensure that the user making the request is the owner of the stash they are attempting to modify. This is achieved by including `user_id: user.id` in the `WHERE` clause of all database queries.
- **Input Validation:** All incoming data (`stashId` and `name`) must be rigorously validated to prevent SQL injection, XSS, and other injection attacks. Zod will be used for body validation, and UUID format will be checked for the path parameter.

## 7. Error Handling
- **400 Bad Request:**
  - If `stashId` is not a valid UUID.
  - If the request body fails validation (e.g., `name` is missing, not a string, empty, or too long).
- **401 Unauthorized:**
  - If the request is made without a valid session cookie.
- **404 Not Found:**
  - If no active stash with the given `stashId` is found for the authenticated user.
- **409 Conflict:**
  - If the user already has an active stash with the same `name`.
- **500 Internal Server Error:**
  - For any other unexpected server-side errors, such as database connection failures.

## 8. Performance
- The database queries will be indexed on `id`, `user_id`, and `name` to ensure fast lookups.
- The entire update operation should be performed within a single database transaction to ensure atomicity and data consistency.
- The response payload is small, so no significant network latency is expected.

## 9. Implementation Steps
1. **Create Service File:** Create a new file at `src/lib/services/stash.service.ts` if it doesn't exist.
2. **Implement Service Function:** In `stash.service.ts`, create and export an async function `updateStashName(supabase: SupabaseClient, stashId: string, newName: string, userId: string): Promise<Stash>`. This function will contain the database logic for updating the stash name.
3. **Add DTO:** Define and export the `UpdateStashNameDto` Zod schema in `src/types.ts` or a new dedicated DTO file.
4. **Create API Route:** Create the file `src/pages/api/stashes/[stashId].ts`.
5. **Implement PATCH Handler:** In the new API route file, export an async function `PATCH({ params, request, context }: APIContext)`. 
6. **Add Logic to Handler:**
   a. Ensure `export const prerender = false;` is set.
   b. Get the authenticated user from `context.locals.supabase`.
   c. Validate the `stashId` path parameter.
   d. Parse and validate the request body using `UpdateStashNameDto`.
   e. Call the `updateStashName` service function with the required arguments.
   f. Implement a `try...catch` block to handle potential errors from the service and return the appropriate HTTP status codes and error messages.
   g. On success, return a `200 OK` response with the updated stash data.
